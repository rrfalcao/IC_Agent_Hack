{"version":3,"sources":["../../src/client/facilitator.ts","../../src/utils/nonce.ts","../../src/utils/validation.ts","../../src/utils/errors.ts","../../src/client/prepareWitness.ts","../../src/client/signWitness.ts","../../src/client/prepareAuthorization.ts","../../src/client/signAuthorization.ts","../../src/utils/encoding.ts","../../src/client/createPaymentHeader.ts","../../src/types/payment.ts","../../src/client/selectPaymentDetails.ts","../../src/client/resourceServer.ts"],"names":["randomBytes","bytesToBigInt","isAddress","signTypedData","toRlp","concat","keccak256","base64"],"mappings":"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","file":"index.js","sourcesContent":["/**\n * Facilitator Client for q402 Protocol\n * \n * HTTP client for communicating with facilitator services.\n * This replaces the local facilitator logic in core package.\n */\n\nimport type { SignedPaymentPayload } from \"../types/payment\";\n\n/**\n * Facilitator API response types (matching x402 standard)\n */\nexport interface FacilitatorVerificationResponse {\n  isValid: boolean;\n  invalidReason?: string;\n  payer?: string;\n  details?: {\n    witnessValid: boolean;\n    authorizationValid: boolean;\n    amountValid: boolean;\n    deadlineValid: boolean;\n    recipientValid: boolean;\n  };\n}\n\nexport interface FacilitatorSettlementResponse {\n  success: boolean;\n  txHash?: string;\n  blockNumber?: string;\n  error?: string;\n}\n\nexport interface FacilitatorSupportedResponse {\n  kinds: Array<{\n    scheme: string;\n    network: string;\n  }>;\n}\n\n/**\n * Standard x402 facilitator client\n */\nexport class FacilitatorClient {\n  constructor(private readonly baseUrl: string) {\n    if (!baseUrl) {\n      throw new Error(\"Facilitator base URL is required\");\n    }\n  }\n\n  /**\n   * Verify a payment payload with the facilitator\n   * POST /verify endpoint\n   */\n  async verify(payload: SignedPaymentPayload): Promise<FacilitatorVerificationResponse> {\n    try {\n      const response = await fetch(`${this.baseUrl}/verify`, {\n        method: \"POST\",\n        headers: {\n          \"Content-Type\": \"application/json\",\n        },\n        body: JSON.stringify(payload),\n      });\n\n      if (!response.ok) {\n        const errorData = await response.json().catch(() => ({})) as any;\n        throw new Error(`Facilitator verification failed: ${response.status} - ${errorData.message || response.statusText}`);\n      }\n\n      return await response.json() as FacilitatorVerificationResponse;\n    } catch (error) {\n      if (error instanceof Error) {\n        throw error;\n      }\n      throw new Error(`Network error during verification: ${error}`);\n    }\n  }\n\n  /**\n   * Settle a payment through the facilitator\n   * POST /settle endpoint\n   */\n  async settle(payload: SignedPaymentPayload): Promise<FacilitatorSettlementResponse> {\n    try {\n      const response = await fetch(`${this.baseUrl}/settle`, {\n        method: \"POST\",\n        headers: {\n          \"Content-Type\": \"application/json\",\n        },\n        body: JSON.stringify(payload),\n      });\n\n      if (!response.ok) {\n        const errorData = await response.json().catch(() => ({})) as any;\n        throw new Error(`Facilitator settlement failed: ${response.status} - ${errorData.message || response.statusText}`);\n      }\n\n      return await response.json() as FacilitatorSettlementResponse;\n    } catch (error) {\n      if (error instanceof Error) {\n        throw error;\n      }\n      throw new Error(`Network error during settlement: ${error}`);\n    }\n  }\n\n  /**\n   * Get supported payment schemes and networks\n   * GET /supported endpoint\n   */\n  async getSupported(): Promise<FacilitatorSupportedResponse> {\n    try {\n      const response = await fetch(`${this.baseUrl}/supported`, {\n        method: \"GET\",\n      });\n\n      if (!response.ok) {\n        const errorData = await response.json().catch(() => ({})) as any;\n        throw new Error(`Failed to get supported schemes: ${response.status} - ${errorData.message || response.statusText}`);\n      }\n\n      return await response.json() as FacilitatorSupportedResponse;\n    } catch (error) {\n      if (error instanceof Error) {\n        throw error;\n      }\n      throw new Error(`Network error getting supported schemes: ${error}`);\n    }\n  }\n\n  /**\n   * Health check endpoint\n   */\n  async health(): Promise<{ status: string }> {\n    try {\n      const response = await fetch(`${this.baseUrl}/health`, {\n        method: \"GET\",\n      });\n\n      if (!response.ok) {\n        throw new Error(`Health check failed: ${response.status}`);\n      }\n\n      return await response.json() as { status: string };\n    } catch (error) {\n      if (error instanceof Error) {\n        throw error;\n      }\n        throw new Error(`Health check error: ${String(error)}`);\n      }\n  }\n}\n\n/**\n * Default facilitator client instance\n * Can be configured via environment variables\n */\nexport function createFacilitatorClient(baseUrl?: string): FacilitatorClient {\n  const url = baseUrl || process.env.FACILITATOR_URL || \"http://localhost:8080\";\n  return new FacilitatorClient(url);\n}\n\n/**\n * Convenience functions for direct API calls\n */\nexport async function verifyPaymentWithFacilitator(\n  payload: SignedPaymentPayload,\n  facilitatorUrl?: string,\n): Promise<FacilitatorVerificationResponse> {\n  const client = createFacilitatorClient(facilitatorUrl);\n  return await client.verify(payload);\n}\n\nexport async function settlePaymentWithFacilitator(\n  payload: SignedPaymentPayload,\n  facilitatorUrl?: string,\n): Promise<FacilitatorSettlementResponse> {\n  const client = createFacilitatorClient(facilitatorUrl);\n  return await client.settle(payload);\n}\n","import { randomBytes } from \"crypto\";\nimport { bytesToBigInt } from \"viem\";\n\n/**\n * Generate a random nonce for payment\n * Uses cryptographically secure random bytes\n */\nexport function generateNonce(): bigint {\n  const bytes = randomBytes(32);\n  return bytesToBigInt(bytes);\n}\n\n/**\n * Generate a payment ID (32-byte hex string)\n */\nexport function generatePaymentId(): `0x${string}` {\n  const bytes = randomBytes(32);\n  return `0x${bytes.toString(\"hex\")}`;\n}\n\n/**\n * Generate an authorization nonce (uint64)\n */\nexport function generateAuthNonce(): bigint {\n  const bytes = randomBytes(8);\n  return bytesToBigInt(bytes);\n}\n\n","import type { Address, Hex } from \"viem\";\nimport { isAddress, isHex } from \"viem\";\n\n/**\n * Validate Ethereum address\n */\nexport function validateAddress(address: unknown): address is Address {\n  return typeof address === \"string\" && isAddress(address);\n}\n\n/**\n * Validate hex string\n */\nexport function validateHex(value: unknown): value is Hex {\n  return typeof value === \"string\" && isHex(value);\n}\n\n/**\n * Validate bigint or bigint string\n */\nexport function validateBigInt(value: unknown): boolean {\n  if (typeof value === \"bigint\") {\n    return value >= 0n;\n  }\n  if (typeof value === \"string\") {\n    return /^\\d+$/.test(value);\n  }\n  return false;\n}\n\n/**\n * Validate deadline (must be in the future)\n */\nexport function validateDeadline(deadline: bigint): boolean {\n  const now = BigInt(Math.floor(Date.now() / 1000));\n  return deadline > now;\n}\n\n/**\n * Validate amount (must be positive)\n */\nexport function validateAmount(amount: bigint): boolean {\n  return amount > 0n;\n}\n\n/**\n * Parse bigint from string or bigint\n */\nexport function parseBigInt(value: string | bigint): bigint {\n  return typeof value === \"bigint\" ? value : BigInt(value);\n}\n\n","/**\n * Base error class for q402 errors\n */\nexport class Q402Error extends Error {\n  constructor(\n    message: string,\n    public readonly code: string,\n    public readonly details?: unknown,\n  ) {\n    super(message);\n    this.name = \"Q402Error\";\n  }\n}\n\n/**\n * Payment validation error\n */\nexport class PaymentValidationError extends Q402Error {\n  constructor(message: string, details?: unknown) {\n    super(message, \"PAYMENT_VALIDATION_ERROR\", details);\n    this.name = \"PaymentValidationError\";\n  }\n}\n\n/**\n * Signature error\n */\nexport class SignatureError extends Q402Error {\n  constructor(message: string, details?: unknown) {\n    super(message, \"SIGNATURE_ERROR\", details);\n    this.name = \"SignatureError\";\n  }\n}\n\n/**\n * Network error\n */\nexport class NetworkError extends Q402Error {\n  constructor(message: string, details?: unknown) {\n    super(message, \"NETWORK_ERROR\", details);\n    this.name = \"NetworkError\";\n  }\n}\n\n/**\n * Transaction error\n */\nexport class TransactionError extends Q402Error {\n  constructor(message: string, details?: unknown) {\n    super(message, \"TRANSACTION_ERROR\", details);\n    this.name = \"TransactionError\";\n  }\n}\n\n","import type { Address, Hex } from \"viem\";\nimport type { WitnessMessage, BatchWitnessMessage, PaymentItem } from \"../types/eip712\";\nimport { generateNonce, generatePaymentId } from \"../utils/nonce\";\nimport { validateAddress, validateAmount } from \"../utils/validation\";\nimport { PaymentValidationError } from \"../utils/errors\";\n\n/**\n * Options for preparing witness message\n */\nexport interface PrepareWitnessOptions {\n  /**\n   * Owner/payer address\n   */\n  owner: Address;\n\n  /**\n   * Token contract address\n   */\n  token: Address;\n\n  /**\n   * Amount in atomic units\n   */\n  amount: bigint | string;\n\n  /**\n   * Recipient address\n   */\n  to: Address;\n\n  /**\n   * Optional deadline (default: 15 minutes from now)\n   */\n  deadline?: bigint;\n\n  /**\n   * Optional payment ID (auto-generated if not provided)\n   */\n  paymentId?: Hex;\n\n  /**\n   * Optional nonce (auto-generated if not provided)\n   */\n  nonce?: bigint;\n}\n\n/**\n * Prepare a witness message for single payment\n */\nexport function prepareWitness(options: PrepareWitnessOptions): WitnessMessage {\n  const { owner, token, amount, to, deadline, paymentId, nonce } = options;\n\n  // Validate inputs\n  if (!validateAddress(owner)) {\n    throw new PaymentValidationError(\"Invalid owner address\");\n  }\n  if (!validateAddress(token)) {\n    throw new PaymentValidationError(\"Invalid token address\");\n  }\n  if (!validateAddress(to)) {\n    throw new PaymentValidationError(\"Invalid recipient address\");\n  }\n\n  const amountBigInt = typeof amount === \"string\" ? BigInt(amount) : amount;\n  if (!validateAmount(amountBigInt)) {\n    throw new PaymentValidationError(\"Invalid amount\");\n  }\n\n  // Generate defaults\n  const finalDeadline = deadline ?? BigInt(Math.floor(Date.now() / 1000) + 900); // 15 minutes\n  const finalPaymentId = paymentId ?? generatePaymentId();\n  const finalNonce = nonce ?? generateNonce();\n\n  return {\n    owner,\n    token,\n    amount: amountBigInt,\n    to,\n    deadline: finalDeadline,\n    paymentId: finalPaymentId,\n    nonce: finalNonce,\n  };\n}\n\n/**\n * Options for preparing batch witness message\n */\nexport interface PrepareBatchWitnessOptions {\n  owner: Address;\n  items: PaymentItem[];\n  deadline?: bigint;\n  paymentId?: Hex;\n  nonce?: bigint;\n}\n\n/**\n * Prepare a batch witness message\n */\nexport function prepareBatchWitness(options: PrepareBatchWitnessOptions): BatchWitnessMessage {\n  const { owner, items, deadline, paymentId, nonce } = options;\n\n  // Validate owner\n  if (!validateAddress(owner)) {\n    throw new PaymentValidationError(\"Invalid owner address\");\n  }\n\n  // Validate items\n  if (!items || items.length === 0) {\n    throw new PaymentValidationError(\"Items array cannot be empty\");\n  }\n\n  for (const item of items) {\n    if (!validateAddress(item.token)) {\n      throw new PaymentValidationError(`Invalid token address: ${item.token}`);\n    }\n    if (!validateAddress(item.to)) {\n      throw new PaymentValidationError(`Invalid recipient address: ${item.to}`);\n    }\n    if (!validateAmount(item.amount)) {\n      throw new PaymentValidationError(`Invalid amount: ${item.amount}`);\n    }\n  }\n\n  // Generate defaults\n  const finalDeadline = deadline ?? BigInt(Math.floor(Date.now() / 1000) + 900); // 15 minutes\n  const finalPaymentId = paymentId ?? generatePaymentId();\n  const finalNonce = nonce ?? generateNonce();\n\n  return {\n    owner,\n    items,\n    deadline: finalDeadline,\n    paymentId: finalPaymentId,\n    nonce: finalNonce,\n  };\n}\n\n","import type { Hex, WalletClient, LocalAccount, PrivateKeyAccount } from \"viem\";\nimport { signTypedData } from \"viem/actions\";\nimport type {\n  WitnessMessage,\n  BatchWitnessMessage,\n  Eip712Domain,\n} from \"../types/eip712\";\nimport { SignatureError } from \"../utils/errors\";\n\n/**\n * Sign a witness message using EIP-712\n */\nexport async function signWitness(\n  account: LocalAccount | PrivateKeyAccount,\n  domain: Eip712Domain,\n  message: WitnessMessage,\n): Promise<Hex> {\n  try {\n    const signature = await account.signTypedData({\n      domain: {\n        name: domain.name,\n        version: domain.version,\n        chainId: domain.chainId,\n        verifyingContract: domain.verifyingContract,\n      },\n      types: {\n        Witness: [\n          { name: \"owner\", type: \"address\" },\n          { name: \"token\", type: \"address\" },\n          { name: \"amount\", type: \"uint256\" },\n          { name: \"to\", type: \"address\" },\n          { name: \"deadline\", type: \"uint256\" },\n          { name: \"paymentId\", type: \"bytes32\" },\n          { name: \"nonce\", type: \"uint256\" },\n        ],\n      },\n      primaryType: \"Witness\",\n      message: {\n        owner: message.owner,\n        token: message.token,\n        amount: message.amount,\n        to: message.to,\n        deadline: message.deadline,\n        paymentId: message.paymentId,\n        nonce: message.nonce,\n      },\n    });\n\n    return signature;\n  } catch (error) {\n    throw new SignatureError(\"Failed to sign witness message\", error);\n  }\n}\n\n/**\n * Sign a witness message using wallet client\n */\nexport async function signWitnessWithWallet(\n  walletClient: WalletClient,\n  domain: Eip712Domain,\n  message: WitnessMessage,\n): Promise<Hex> {\n  try {\n    if (!walletClient.account) {\n      throw new SignatureError(\"Wallet client has no account\");\n    }\n\n    const signature = await signTypedData(walletClient, {\n      account: walletClient.account,\n      domain: {\n        name: domain.name,\n        version: domain.version,\n        chainId: domain.chainId,\n        verifyingContract: domain.verifyingContract,\n      },\n      types: {\n        Witness: [\n          { name: \"owner\", type: \"address\" },\n          { name: \"token\", type: \"address\" },\n          { name: \"amount\", type: \"uint256\" },\n          { name: \"to\", type: \"address\" },\n          { name: \"deadline\", type: \"uint256\" },\n          { name: \"paymentId\", type: \"bytes32\" },\n          { name: \"nonce\", type: \"uint256\" },\n        ],\n      },\n      primaryType: \"Witness\",\n      message: {\n        owner: message.owner,\n        token: message.token,\n        amount: message.amount,\n        to: message.to,\n        deadline: message.deadline,\n        paymentId: message.paymentId,\n        nonce: message.nonce,\n      },\n    });\n\n    return signature;\n  } catch (error) {\n    throw new SignatureError(\"Failed to sign witness message with wallet\", error);\n  }\n}\n\n/**\n * Sign a batch witness message\n */\nexport async function signBatchWitness(\n  account: LocalAccount | PrivateKeyAccount,\n  domain: Eip712Domain,\n  message: BatchWitnessMessage,\n): Promise<Hex> {\n  try {\n    const signature = await account.signTypedData({\n      domain: {\n        name: domain.name,\n        version: domain.version,\n        chainId: domain.chainId,\n        verifyingContract: domain.verifyingContract,\n      },\n      types: {\n        PaymentItem: [\n          { name: \"token\", type: \"address\" },\n          { name: \"amount\", type: \"uint256\" },\n          { name: \"to\", type: \"address\" },\n        ],\n        BatchWitness: [\n          { name: \"owner\", type: \"address\" },\n          { name: \"items\", type: \"PaymentItem[]\" },\n          { name: \"deadline\", type: \"uint256\" },\n          { name: \"paymentId\", type: \"bytes32\" },\n          { name: \"nonce\", type: \"uint256\" },\n        ],\n      },\n      primaryType: \"BatchWitness\",\n      message,\n    });\n\n    return signature;\n  } catch (error) {\n    throw new SignatureError(\"Failed to sign batch witness message\", error);\n  }\n}\n\n","import type { Address } from \"viem\";\nimport type { UnsignedAuthorizationTuple } from \"../types/eip7702\";\nimport { generateAuthNonce } from \"../utils/nonce\";\nimport { validateAddress } from \"../utils/validation\";\nimport { PaymentValidationError } from \"../utils/errors\";\n\n/**\n * Options for preparing authorization tuple\n */\nexport interface PrepareAuthorizationOptions {\n  /**\n   * Chain ID (0 for any chain, or specific chain ID)\n   */\n  chainId: bigint | number;\n\n  /**\n   * Implementation contract address to delegate to\n   */\n  implementationAddress: Address;\n\n  /**\n   * Optional authorization nonce (auto-generated if not provided)\n   */\n  nonce?: bigint | number;\n}\n\n/**\n * Prepare an unsigned authorization tuple for EIP-7702\n */\nexport function prepareAuthorization(\n  options: PrepareAuthorizationOptions,\n): UnsignedAuthorizationTuple {\n  const { chainId, implementationAddress, nonce } = options;\n\n  // Validate implementation address\n  if (!validateAddress(implementationAddress)) {\n    throw new PaymentValidationError(\"Invalid implementation contract address\");\n  }\n\n  // Convert chain ID to bigint\n  const chainIdBigInt = typeof chainId === \"number\" ? BigInt(chainId) : chainId;\n\n  // Generate nonce if not provided\n  const finalNonce =\n    nonce !== undefined\n      ? typeof nonce === \"number\"\n        ? BigInt(nonce)\n        : nonce\n      : generateAuthNonce();\n\n  return {\n    chainId: chainIdBigInt,\n    address: implementationAddress,\n    nonce: finalNonce,\n  };\n}\n\n","import type { Hex, LocalAccount, PrivateKeyAccount } from \"viem\";\nimport { keccak256, concat, toRlp } from \"viem\";\nimport type { UnsignedAuthorizationTuple, AuthorizationTuple } from \"../types/eip7702\";\nimport { SignatureError } from \"../utils/errors\";\n\n/**\n * Sign an authorization tuple for EIP-7702\n * Computes: keccak256(0x05 || rlp([chain_id, address, nonce]))\n */\nexport async function signAuthorization(\n  account: LocalAccount | PrivateKeyAccount,\n  authorization: UnsignedAuthorizationTuple,\n): Promise<AuthorizationTuple> {\n  try {\n    // Encode authorization data\n    const encoded = toRlp([\n      authorization.chainId === 0n ? \"0x\" : `0x${authorization.chainId.toString(16)}`,\n      authorization.address,\n      authorization.nonce === 0n ? \"0x\" : `0x${authorization.nonce.toString(16)}`,\n    ]);\n\n    // Prepend 0x05 type prefix\n    const message = concat([\"0x05\", encoded]);\n\n    // Hash the message\n    const hash = keccak256(message);\n\n    // Sign the hash\n    const signature = await account.signMessage({\n      message: { raw: hash },\n    });\n\n    // Parse signature (viem returns r,s,v format)\n    const r = signature.slice(0, 66) as Hex;\n    const s = `0x${signature.slice(66, 130)}` as Hex;\n    const v = parseInt(signature.slice(130, 132), 16);\n\n    // Convert v to y_parity (27/28 -> 0/1)\n    const yParity = v >= 27 ? v - 27 : v;\n\n    return {\n      chainId: authorization.chainId,\n      address: authorization.address,\n      nonce: authorization.nonce,\n      yParity,\n      r,\n      s,\n    };\n  } catch (error) {\n    throw new SignatureError(\"Failed to sign authorization tuple\", error);\n  }\n}\n\n/**\n * Verify an authorization signature\n */\nexport async function verifyAuthorizationSignature(\n  authorization: AuthorizationTuple,\n  expectedSigner: Hex,\n): Promise<boolean> {\n  try {\n    const { recoverMessageAddress } = await import(\"viem\");\n    \n    // Encode authorization data\n    const encoded = toRlp([\n      authorization.chainId === 0n ? \"0x\" : `0x${authorization.chainId.toString(16)}`,\n      authorization.address,\n      authorization.nonce === 0n ? \"0x\" : `0x${authorization.nonce.toString(16)}`,\n    ]);\n\n    // Prepend 0x05 type prefix\n    const message = concat([\"0x05\", encoded]);\n\n    // Hash the message\n    const hash = keccak256(message);\n\n    // Reconstruct signature from components\n    const v = authorization.yParity + 27;\n    const signature = concat([\n      authorization.r,\n      authorization.s,\n      `0x${v.toString(16).padStart(2, \"0\")}` as Hex,\n    ]);\n\n    // Recover signer address\n    const recovered = await recoverMessageAddress({\n      message: { raw: hash },\n      signature,\n    });\n\n    // Verify signer matches expected\n    return recovered.toLowerCase() === expectedSigner.toLowerCase();\n  } catch {\n    return false;\n  }\n}\n\n","import { base64 } from \"@scure/base\";\nimport type { Hex } from \"viem\";\n\n/**\n * Encode data to base64 string\n */\nexport function encodeBase64(data: string | object): string {\n  const str = typeof data === \"string\" ? data : JSON.stringify(data);\n  const bytes = new TextEncoder().encode(str);\n  return base64.encode(bytes);\n}\n\n/**\n * Decode base64 string to object\n */\nexport function decodeBase64<T = unknown>(encoded: string): T {\n  const bytes = base64.decode(encoded);\n  const str = new TextDecoder().decode(bytes);\n  return JSON.parse(str) as T;\n}\n\n/**\n * RLP encode authorization tuple for EIP-7702\n * Format: rlp([chain_id, address, nonce])\n */\nexport function rlpEncodeAuthorization(\n  chainId: bigint,\n  address: Hex,\n  nonce: bigint,\n): Uint8Array {\n  // Simple RLP encoding for authorization tuple\n  // This is a basic implementation - in production, use a proper RLP library\n  const items = [\n    encodeRlpItem(chainId),\n    encodeRlpItem(address),\n    encodeRlpItem(nonce),\n  ];\n\n  return encodeRlpList(items);\n}\n\n/**\n * Encode a single RLP item\n */\nfunction encodeRlpItem(value: bigint | string): Uint8Array {\n  if (typeof value === \"bigint\") {\n    // Encode bigint as bytes\n    if (value === 0n) {\n      return new Uint8Array([0x80]); // Empty string\n    }\n    const hex = value.toString(16).padStart(value.toString(16).length % 2 === 0 ? 0 : 1, \"0\");\n    const bytes = hexToBytes(hex);\n    return encodeRlpString(bytes);\n  } else {\n    // Encode hex string\n    const bytes = hexToBytes(value.replace(/^0x/, \"\"));\n    return encodeRlpString(bytes);\n  }\n}\n\n/**\n * Encode RLP string\n */\nfunction encodeRlpString(bytes: Uint8Array): Uint8Array {\n  if (bytes.length === 1 && bytes[0] < 0x80) {\n    return bytes;\n  }\n  if (bytes.length <= 55) {\n    return new Uint8Array([0x80 + bytes.length, ...bytes]);\n  }\n  const lengthBytes = numberToBytes(bytes.length);\n  return new Uint8Array([0xb7 + lengthBytes.length, ...lengthBytes, ...bytes]);\n}\n\n/**\n * Encode RLP list\n */\nfunction encodeRlpList(items: Uint8Array[]): Uint8Array {\n  const concatenated = new Uint8Array(items.reduce((acc, item) => acc + item.length, 0));\n  let offset = 0;\n  for (const item of items) {\n    concatenated.set(item, offset);\n    offset += item.length;\n  }\n\n  if (concatenated.length <= 55) {\n    return new Uint8Array([0xc0 + concatenated.length, ...concatenated]);\n  }\n  const lengthBytes = numberToBytes(concatenated.length);\n  return new Uint8Array([0xf7 + lengthBytes.length, ...lengthBytes, ...concatenated]);\n}\n\n/**\n * Convert hex string to bytes\n */\nfunction hexToBytes(hex: string): Uint8Array {\n  const bytes = new Uint8Array(hex.length / 2);\n  for (let i = 0; i < hex.length; i += 2) {\n    bytes[i / 2] = parseInt(hex.slice(i, i + 2), 16);\n  }\n  return bytes;\n}\n\n/**\n * Convert number to bytes\n */\nfunction numberToBytes(num: number): Uint8Array {\n  const hex = num.toString(16).padStart(num.toString(16).length % 2 === 0 ? 0 : 1, \"0\");\n  return hexToBytes(hex);\n}\n\n","import type { LocalAccount, PrivateKeyAccount, WalletClient } from \"viem\";\nimport type { PaymentDetails, SignedPaymentPayload } from \"../types/payment\";\nimport type { Eip712Domain } from \"../types/eip712\";\nimport { prepareWitness } from \"./prepareWitness\";\nimport { signWitness, signWitnessWithWallet } from \"./signWitness\";\nimport { prepareAuthorization } from \"./prepareAuthorization\";\nimport { signAuthorization } from \"./signAuthorization\";\nimport { encodeBase64 } from \"../utils/encoding\";\n\n/**\n * Create a complete payment header for X-PAYMENT\n */\nexport async function createPaymentHeader(\n  account: LocalAccount | PrivateKeyAccount,\n  paymentDetails: PaymentDetails,\n): Promise<string> {\n  // Prepare witness message\n  const witnessMessage = prepareWitness({\n    owner: account.address,\n    token: paymentDetails.token,\n    amount: paymentDetails.amount,\n    to: paymentDetails.to,\n  });\n\n  // Create domain from payment details\n  const domain: Eip712Domain = {\n    name: \"q402\",\n    version: \"1\",\n    chainId: paymentDetails.authorization.chainId,\n    verifyingContract: paymentDetails.authorization.address,\n  };\n\n  // Sign witness\n  const witnessSignature = await signWitness(account, domain, witnessMessage);\n\n  // Prepare authorization\n  const unsignedAuth = prepareAuthorization({\n    chainId: paymentDetails.authorization.chainId,\n    implementationAddress: paymentDetails.implementationContract,\n    nonce: paymentDetails.authorization.nonce,\n  });\n\n  // Sign authorization\n  const signedAuth = await signAuthorization(account, unsignedAuth);\n\n  // Create signed payload\n  const payload: SignedPaymentPayload = {\n    witnessSignature,\n    authorization: signedAuth,\n    paymentDetails,\n  };\n\n  // Encode to base64 for X-PAYMENT header\n  return encodeBase64(payload);\n}\n\n/**\n * Create payment header using wallet client\n */\nexport async function createPaymentHeaderWithWallet(\n  walletClient: WalletClient,\n  paymentDetails: PaymentDetails,\n): Promise<string> {\n  if (!walletClient.account) {\n    throw new Error(\"Wallet client has no account\");\n  }\n\n  // Prepare witness message\n  const witnessMessage = prepareWitness({\n    owner: walletClient.account.address,\n    token: paymentDetails.token,\n    amount: paymentDetails.amount,\n    to: paymentDetails.to,\n  });\n\n  // Create domain\n  const domain: Eip712Domain = {\n    name: \"q402\",\n    version: \"1\",\n    chainId: paymentDetails.authorization.chainId,\n    verifyingContract: paymentDetails.authorization.address,\n  };\n\n  // Sign witness\n  const witnessSignature = await signWitnessWithWallet(walletClient, domain, witnessMessage);\n\n  // For authorization, we need to use the account\n  const unsignedAuth = prepareAuthorization({\n    chainId: paymentDetails.authorization.chainId,\n    implementationAddress: paymentDetails.implementationContract,\n    nonce: paymentDetails.authorization.nonce,\n  });\n\n  // Sign authorization (requires LocalAccount)\n  const signedAuth = await signAuthorization(\n    walletClient.account as LocalAccount | PrivateKeyAccount,\n    unsignedAuth,\n  );\n\n  // Create signed payload\n  const payload: SignedPaymentPayload = {\n    witnessSignature,\n    authorization: signedAuth,\n    paymentDetails,\n  };\n\n  return encodeBase64(payload);\n}\n\n","import type { Address, Hex } from \"viem\";\nimport type { AuthorizationTuple } from \"./eip7702\";\nimport type { WitnessTypedData, BatchWitnessTypedData, PaymentItem } from \"./eip712\";\nimport type { SupportedNetwork } from \"./network\";\n\n// Re-export PaymentItem for external use\nexport type { PaymentItem } from \"./eip712\";\n\n/**\n * Payment scheme identifier\n */\nexport const PaymentScheme = {\n  EIP7702_DELEGATED: \"evm/eip7702-delegated-payment\",\n  EIP7702_DELEGATED_BATCH: \"evm/eip7702-delegated-batch\",\n} as const;\n\nexport type PaymentSchemeType = (typeof PaymentScheme)[keyof typeof PaymentScheme];\n\n/**\n * Payment details returned by resource server in 402 response\n */\nexport interface PaymentDetails {\n  /**\n   * Payment scheme identifier\n   */\n  scheme: PaymentSchemeType;\n\n  /**\n   * Network identifier\n   */\n  networkId: SupportedNetwork;\n\n  /**\n   * Token contract address\n   */\n  token: Address;\n\n  /**\n   * Payment amount in atomic units\n   */\n  amount: string;\n\n  /**\n   * Recipient address (resource server settlement wallet)\n   */\n  to: Address;\n\n  /**\n   * Implementation contract address (whitelisted delegation target)\n   */\n  implementationContract: Address;\n\n  /**\n   * EIP-712 witness typed data\n   */\n  witness: WitnessTypedData | BatchWitnessTypedData;\n\n  /**\n   * Authorization tuple template (without signature)\n   */\n  authorization: {\n    chainId: number;\n    address: Address;\n    nonce: number;\n  };\n}\n\n/**\n * Batch payment details\n */\nexport interface BatchPaymentDetails extends Omit<PaymentDetails, \"token\" | \"amount\" | \"witness\"> {\n  scheme: typeof PaymentScheme.EIP7702_DELEGATED_BATCH;\n  items: PaymentItem[];\n  witness: BatchWitnessTypedData;\n}\n\n/**\n * Signed payment payload for X-PAYMENT header\n */\nexport interface SignedPaymentPayload {\n  /**\n   * Witness signature (EIP-712)\n   */\n  witnessSignature: Hex;\n\n  /**\n   * Signed authorization tuple (EIP-7702)\n   */\n  authorization: AuthorizationTuple;\n\n  /**\n   * Payment details\n   */\n  paymentDetails: PaymentDetails | BatchPaymentDetails;\n}\n\n/**\n * 402 Payment Required response\n */\nexport interface PaymentRequiredResponse {\n  /**\n   * Protocol version\n   */\n  x402Version: number;\n\n  /**\n   * Accepted payment methods\n   */\n  accepts: PaymentDetails[];\n\n  /**\n   * Optional error message\n   */\n  error?: string;\n}\n\n/**\n * Payment execution response\n */\nexport interface PaymentExecutionResponse {\n  /**\n   * Transaction hash\n   */\n  txHash: Hex;\n\n  /**\n   * Block number\n   */\n  blockNumber?: bigint;\n\n  /**\n   * Transaction status\n   */\n  status: \"pending\" | \"confirmed\" | \"failed\";\n\n  /**\n   * Transfer events or receipts\n   */\n  transfers?: Array<{\n    token: Address;\n    from: Address;\n    to: Address;\n    amount: bigint;\n  }>;\n\n  /**\n   * Error message if failed\n   */\n  error?: string;\n}\n\n","import type { PaymentRequiredResponse, PaymentDetails } from \"../types/payment\";\nimport { PaymentScheme } from \"../types/payment\";\nimport type { SupportedNetwork } from \"../types/network\";\n\n/**\n * Options for selecting payment details\n */\nexport interface SelectPaymentDetailsOptions {\n  /**\n   * Preferred network (optional)\n   */\n  network?: SupportedNetwork;\n\n  /**\n   * Preferred scheme (optional)\n   */\n  scheme?: string;\n\n  /**\n   * Maximum amount willing to pay (optional)\n   */\n  maxAmount?: bigint;\n}\n\n/**\n * Select payment details from 402 response\n * Returns the first matching payment option, or the first available if no preferences match\n */\nexport function selectPaymentDetails(\n  response: PaymentRequiredResponse,\n  options?: SelectPaymentDetailsOptions,\n): PaymentDetails | null {\n  if (!response.accepts || response.accepts.length === 0) {\n    return null;\n  }\n\n  const { network, scheme, maxAmount } = options ?? {};\n\n  // Filter by preferences\n  let candidates = response.accepts;\n\n  if (network) {\n    const filtered = candidates.filter((details) => details.networkId === network);\n    if (filtered.length > 0) {\n      candidates = filtered;\n    }\n  }\n\n  if (scheme) {\n    const filtered = candidates.filter((details) => details.scheme === scheme);\n    if (filtered.length > 0) {\n      candidates = filtered;\n    }\n  }\n\n  if (maxAmount !== undefined) {\n    const filtered = candidates.filter((details) => BigInt(details.amount) <= maxAmount);\n    if (filtered.length > 0) {\n      candidates = filtered;\n    }\n  }\n\n  // Return first candidate\n  return candidates[0] ?? null;\n}\n\n/**\n * Check if payment details are supported by this client\n */\nexport function isPaymentDetailsSupported(details: PaymentDetails): boolean {\n  // Check scheme\n  const supportedSchemes = [PaymentScheme.EIP7702_DELEGATED, PaymentScheme.EIP7702_DELEGATED_BATCH];\n  if (!supportedSchemes.includes(details.scheme as (typeof supportedSchemes)[number])) {\n    return false;\n  }\n\n  // Check network (BSC mainnet/testnet)\n  const supportedNetworks = [\"bsc-mainnet\", \"bsc-testnet\"];\n  if (!supportedNetworks.includes(details.networkId)) {\n    return false;\n  }\n\n  return true;\n}\n\n","/**\n * Resource Server Helper for q402 Protocol\n * \n * Helper functions for resource servers implementing x402 payment flow\n */\n\nimport type { PaymentRequiredResponse, PaymentDetails } from \"../types/payment\";\n\n/**\n * Standard x402 payment header format\n */\nexport interface PaymentHeader {\n  x402Version: number;\n  scheme: string;\n  network: string;\n  payload: unknown;\n}\n\n/**\n * Standard x402 payment requirement format\n */\nexport interface PaymentRequirement {\n  scheme: string;\n  network: string;\n  maxAmountRequired: string;\n  resource: string;\n  description: string;\n  mimeType: string;\n  payTo: string;\n  maxTimeoutSeconds: number;\n  asset: string;\n  extra?: object;\n}\n\n/**\n * Create a 402 Payment Required response\n */\nexport function createPaymentRequired(\n  accepts: PaymentDetails[],\n  error?: string,\n): PaymentRequiredResponse {\n  return {\n    x402Version: 1,\n    accepts,\n    error,\n  };\n}\n\n/**\n * Parse X-PAYMENT header\n */\nexport function parsePaymentHeader(header: string): PaymentHeader {\n  try {\n    const decoded = Buffer.from(header, 'base64').toString('utf8');\n    return JSON.parse(decoded);\n  } catch (error) {\n    throw new Error(`Invalid X-PAYMENT header: ${error}`);\n  }\n}\n\n/**\n * Create X-PAYMENT-RESPONSE header content\n */\nexport function createPaymentResponse(\n  success: boolean,\n  options?: {\n    error?: string;\n    txHash?: string;\n    networkId?: string;\n    blockNumber?: string;\n  },\n): string {\n  const response = {\n    success,\n    ...options,\n  };\n  \n  return Buffer.from(JSON.stringify(response)).toString('base64');\n}\n\n/**\n * Validate payment header against requirements\n */\nexport function validatePaymentHeader(\n  header: PaymentHeader,\n  requirement: PaymentRequirement,\n): { isValid: boolean; reason?: string } {\n  if (header.scheme !== requirement.scheme) {\n    return { isValid: false, reason: `Scheme mismatch: expected ${requirement.scheme}, got ${header.scheme}` };\n  }\n  \n  if (header.network !== requirement.network) {\n    return { isValid: false, reason: `Network mismatch: expected ${requirement.network}, got ${header.network}` };\n  }\n  \n  if (header.x402Version !== 1) {\n    return { isValid: false, reason: `Unsupported x402 version: ${header.x402Version}` };\n  }\n  \n  return { isValid: true };\n}\n\n/**\n * Create payment requirement for EIP-7702 delegated payments\n */\nexport function createEip7702PaymentRequirement(\n  amount: string,\n  tokenAddress: string,\n  recipientAddress: string,\n  resource: string,\n  description: string,\n  network: string = \"bsc-mainnet\",\n  mimeType: string = \"application/json\",\n): PaymentRequirement {\n  return {\n    scheme: \"evm/eip7702-signature-based\",\n    network,\n    maxAmountRequired: amount,\n    resource,\n    description,\n    mimeType,\n    payTo: recipientAddress,\n    maxTimeoutSeconds: 60,\n    asset: tokenAddress,\n    extra: {\n      name: \"q402\",\n      version: \"1\",\n    },\n  };\n}\n"]}